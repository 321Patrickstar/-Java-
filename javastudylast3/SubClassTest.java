package javastudylast3;

public class SubClassTest {
    public static void main(String[] args) {
        //SubClass.method
        //知识点1.接口中定义的静态方法，只能通过接口来调用
        Attack.method();
        //通过实现对象可以调用接口类的默认方法
        //接口可以继承接口,抽象类可以实现接口,抽象类可以继承实体类。
        SubClass s = new SubClass();
        //c从父类哪来的默认方法
        //如果是实现类重写了接口的默认方法，仍然调用重重写的
        //方法
        //知识点3，如果子类（实现类）继承的父类和实现的接口中（针对默认方法）
        //声明了同名同参数的方法的情况下（接口的默认方法和父类方法同名同参数）
        // 在子类没有重写此方法的情况下，默认调用的是父类中的同名同参数的方法
        //类优先的原则
        //知识点4，如果这个实现类，实现了多个接口，而这个接口定义了同名同参数的默认方法
        //在实现类没有重现次方法的情况下，即接口冲突，必须在实现类中重写此方法，调就是重写的方法了
        s.method2();
        s.attack();
        /*
        *抽象类是用来捕捉子类的通用特性的，而接口则是抽象方法的集合；抽象类不能被实例化，只
能被用作子类的超类，是被用来创建继承层级里子类的模板，而接口只是一种形式，接口自身
不能做任何事情
其次，抽象类可以有默认的方法实现，子类使用 extends关键字来继承抽象类，如果子类不是
抽象类的话，它需要提供抽象类中所有声明方法的实现。而接口完全是抽象的，它根本不存在
方法的实现，子类使用关键字 implements来实现接口，它需要提供接口中所有声明方法的实
现
抽象类可以有构造器，除了不能实例化抽象类之外，它和普通Java类没有任何区别，抽象方法
可以有 public、 protected和 default这些修饰符。而接口不能有构造器，是完全不同的类
型，接口方法默认修饰符是 public,不可以使用其它修饰符。
        *
        * */



    }
}
class SubClass implements Attack{


    @Override
    public void attack() {

    }

    @Override
    public void method2() {
        Attack.super.method2();//如何在子类或者实现类调用父类，接口中被重写的方法
    }
}
