package javastudymiddle;
/*
1.面向对象的特性继承extends
2.减少了代码的冗余，提高了代码的复用性
3.便于功能的扩展
4.为后续的多态做准备
5.子类派生类(subclass)父类，超类，基类(superclass)(子类指向父类）
6.子类继承了父类的属性，方法，特别的，父类中声明的private的属性和方法，子类继承父类以后，任然认为获取了
父类，只有因为封装性的影响，使得子类不能直接调用父类的结构
7.子类在继承父类之后还可以自己定义自己的方法和属性，实现功能的扩展不同于集合和子集
8.一个类可以被多个子类继承，一个类只能一个父类java中类的单继承型，子父类是相对的，没有爷孙（间接父类)
9.子类继承父类后，就获得了直接父类和所有间接父类的所有属性和方法
10.父类object,如果我们没有声明一个类的父类的话，则此类继承于Java。狼。object类
11.所有的java类（Java.lang.object类之外），都直接或间接的继承于Java.lang.object类
12.所有java类都继承于object类中内容
13.debug的时候有时进入不了这个方法
14.方法的重写，1，在子类继承父类之后，可以对父类的（同名同参）的方法进行覆盖
15.重写之后，当创建类对象以后，通过子类对象调用父类中的同名同参数的方式时，实际执行
子类重写父类的的对象
16.父类的还是调用自己的，子类可以对同名同参的进行覆盖，这样就能变成子类自己的
17.区分重载和重写
18.重写的规定：
约定俗成，子类重写的方法，父类中被重写的方法，
方法名和形参列表相同，子类重写的方法的权限修饰符不小于父类被重写的方法的权限修饰符
子类不能重写父类的privat的方法（太小了都看不到）
19.1如果父类被重写的返回值是void，子类重写也是void，
2父类被重写的返回而类型是A类，子类被重写的方法可以是A类或者是A类的子类
3可以是父类方法的一个子类
4如果父类被重写的返回类型是double，那么子类重写的方法的返回类型也是double
5（我们不能说int是double类的一个子类）
6.子类重写的方法的异常类型不大于父类被重写的方法抛出的具体类型
20.子类和父类同名同参数的方法要么都声明为非static的（考虑重写），要么都申明为static的（不是重写）
21.子类重写的与父类被重写的方法的区分，super理解为父类的...this.gae,super.age;
22.子父类的属性也相同，不会重叠，默认（省略this）调用的都是自己类下的属性，如果想调用父类用super
23.我们可以在子类的方法和构造器中，通过super。属性super.方法显示的调用父类的属性和方法，但是通常情况下我们会省略
24.特殊情况，当子类和父类中定义了同名的属性时，我们想要在子类中调用父类的的要加super重写的方法用super
25.在子类的构造器中显示的super调用父类的指定的构造器super（有无形参）
26.调用父类构造器要申明要申明在首行this（形参列表），super(新参列表），子类
27.在构造器的首行没有显示的声明this（形参列表），super(新参列表），则默认super(新参列表）出现错误父类没有空参构造器
子类又默认调用，就出错了
28.子类对象实例化的全过程
1.从结果上来看。
子类继承父类之后，就获取了父类中声明的属性和方法
创建子类的对象，在堆空间中，就会加载所有父类的声明的属性
2.从过程上来看。
子类创建对象会调用父类的构造器，父类也会调用父类的构造器，或者是间接，父类的父类的构造器
直到调用到Java.lang.object.类中的空参构造器为止，正因为加载过所有父类的结构，所以才可以看到内存中有父类中的结构
子类对象才可以考虑进行调用
虽然创建子类对象时，调用了父类的构造器,但是自始至终就创建一个对象，即为new的子类对象
29面向对象多态性，一个事物的多种形态
30.多态的使用，虚拟方法的调用
有了对象的多态性雨后，我们再编译期只能调用父类中声明的方法
执行和运行的是子类重写父类的方法
31.多态性的使用前提，类得有继承关系，要有方法的重写，当我们要从父类（形参是父类）我们要想调用子类的重写的方法
32，让一个哟没有多态，我是要编译相关的重载函数，来调用子类的重写的方法，并且对象还是得是子类的
33.例子，多态，父类写的调用方法，有三四哥不一样的数据库，每个数据都有自己的调用方法，此时如果不用多态的话
我们就要写很多关于此数据库的重载方法，来调用此数据库的重写方法，多态就不用直接父类对象创建对应数据库类型就行了
再main方法里就不用重写了（也算是调用公共方法）
34，对象的方法只适用于方法，不适用属性（只看左边）
35.多态也就是晚绑定（只有运行才知道调用那个，晚绑定
36.由于父类不能调用子类的特有的方法
有了多态性以后内村实际上是加载了子类特有的属性和方法的，但是由于变量声明为父类类型
编译时，只能调用父类中声明的属性和方法，子类的特殊的属性和方法不能调用
37.如何去调用子类的放法，你可以把父类的对象类型强制转换成对应类型
Student s1 = (Student)p2;向下转型（子类变成父类多态）（你创建一个父类，却能使用子类重写的方法，不就相当于
创建一个（子类变成父类）的父类的对象了么，如果是父类想调用热油的方法，你就得父类变成子类就是强转
使用强转的时候会容易报错，为了避免出现这个错误
38 关键字的使用instanceof的使用，
判断对象a是不是类A的一个实例，如果是返回true，如果不是，返回false
a instanceof A为了在向下转型出现异常先进行向下转型，如果true转型可以，如果force则转型不可以一般都是面对子父类的
父类调用重写的方法多态，父类调用特有的方法，向下转型，instanceof判断可不可向下转型
39.object类是所有Java类的根父类，只要没有显示的extends，object类中的属性和方法具有通用性
object只有空参构造器Clone（）复制对象equals()比较两个对象是否相等
39.考察Final ，finally ，finalize
40.等等==运算符（基本和引用类型）如果是比较两个基本数据类型的变量，比较两个变量的数据是否相等（类型不一定相等）
如果是两个引用类型的变量比较的是两个变量的地址（即两个引用是否指向同一个的对象）
引用类型创造变量都是new在堆空间里变量名是个地址指向堆控件得对象
但是c++都是放在栈区域所以c++两个同类型的变量可以相等，但是java对于引用类型就不行string例子；
和Equals的使用只能适用于引用数据类型，是方法
object当中的equals方法和==的运算符一样的
像string，date ，file，包装类都重写了equals方法，不是地址了，而是两个对象的实体内容
通常情况下，我们自定义的类，equals类也是想让内容相等，可以对equals进行重写
41，tostring的使用，但我们输出一个对象的引用的时候，实际上是调用了这个tostring的方法object是地址
像string，date ，file，包装类都重写了tostring的方法，输出了对象代表的实体而不是地址
通常情况下，我们自定义的类，tostring类也是想让内容相等，可以对tostring进行重写
42.单元测试方法,JUnit
步骤，
43.希望基本类型，也能够变成类，所以把类包装了一下包装类，类里面的方法就可以使用了也定义了丰富的方法
除了int 是Integer，char是Character其他都是大写，基本类型和包装类和string类之间如何相互转换







 */
public class Test {
    public static void main(String[] args) {
        Person p1 =new Person();
        p1.eat();
        Student s1 =new Student();
        s1.eat();
        s1.name ="apple";
        //多态性（子类对象的多态性）
        //对象的多态性
        //我们左面声明一个变量右面创建一个的对象
        //这个对象具有多种形态，父类的引用指向子类的对象
        Person p2 = new Teacher();//在这里当使用堕多态的时候，父类的被重写的方法则是虚方法，
        p2.eat();//调用了子类重写的方法
        //多态的使用，当调用子父类同名同参的方法时，实际执行的
        //是子类重写父类的方法---虚拟方法的调用
        //也只能调用person类中声明的方法，不能调用子类的特殊方法
        //编译的时候看的是左边P2，但是运行的时候看的是右边




    }
}
