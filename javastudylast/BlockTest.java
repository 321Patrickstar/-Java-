package javastudylast;
/*
* 类成员四，代码块（初始化快）
* 代码块的作用，用来初始化类和对象
* 类中代码快的修饰，如果修饰只能static
* 静态方法他是随着类的加载而加载，但是如果不调用的话
* 不会执行，静态代码块则是不光加载了还执行了
* 代码快
* 内部可以有输出语句（代码快先于构造器）
* 随着对象的创建而执行,每创建一次对象，就执行一次
* 用来对对象的属性初始化属性赋值（默认初始化，显示初始化，构造器初始化，对象点，对象方法。）
*非静态也是声明先后顺序
* 可以调用静态的成员，非静态成员（属性方法）
*
*
* 静态代码块（的执行先于构造器）
* （可以定义多个，执行顺序。先后声明顺序）要优先于非静态
*  内部可以有输出语句
* 随着类的加载和执行
* 且只执行一次
* 就额可以初始化一些类的属性（有的属性不是直接初始化，是得用方法来初始化），就放在代码快
* 你不能放在属性，你不能放在方法来初始化，每调用一次都要初始化（懒汉模式，你得判断null不null）
* 那时候就可以写在代码快里面了
* 不能调用非静态的成员
*
*
* 练习多类子父类嵌套
* 接口构造子类对象，调用子类构造器
* 子类构造器看看父类是怎么加载的（每个子类构造器继承父类都有个super.())
* 子类构造器调用父类有参构造器，父类有参构造器调用父类构造器（自己对象的构造器）（编译环节）
* 父类的无参构造器隐式调用父类的父类构造器，再到间接父类构造器（根构造器）
* 间接父类构造器，也要调用所有类的根构造器Java。lang。object类的构造器
* （加载环节）在内存中先把object类的相关结构先加载，之后是加载间接父类然后就是间接父类静态的只有（代码快）就出来了
* 间接父类的所有静态内容，非静态的不调用，没对象，然后是父类静态代码，然会是子类静态代码
* 运行环节我们是new一个子类对象有代码块先调用代码块，然后再构造器
* 总结按照加载顺序，先调用根类的构造器，但是代码快实在构造器之前，静态又在前，所以加载
* 间接父类的静态代码块和非静态代码块然后调用间接父类构造器，再次新建子类对象静态代码块也就
* 没有了只执行一次
* 总结由父及子，静态先行
* 你还没创建对象的时候，main方法调用（类）也得通过类去调用先加载父类子类静态
* 从运行上看main调用了并没造对象，但是内存中加载了类，并执行了由父及子，类的静态
* 单号新建对象是静态只一次，所以是父类非静态+构造器，加子类静态+构造器
* 堆属性赋值的顺序
* 默认初始化
* 显示初始化/在代码块中赋值(这里得看谁先谁后）
* 构造器中初始化
* 有了对像，对象.对象方法.
*
*
*
* */
public class BlockTest {
    public static void main(String[] args) {
        String s = Person.description;
        Person p1 = new Person();
    }
}
class Person{
    String name;
    int age;
    static String description = "I AM A MAN";

    public Person() {
    }

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
    //代码快
    {
        System.out.println("");
    }
    //静态代码块
    static
    {
        description = "I LOVE STUDY";
        System.out.println("");
    }
    public void eat(){
        System.out.println("have lunch");
    }
    public String toString(){
        return "Person[ name"+name+",age="+age+"]";
    }
}
